Description

Approach

	Overall: I programmed this software bottom up because I knew we needed to use Queues, PrioirtyQueues, Movies, and Heap sort.
	So I started with implementing those objects fully, testing along the way and creating modular code. After the main building 
	blocks were done I started to abstract them with layer upon layer of classes that would piece together each part of the program
	so that each class knows nothing of the object it held, only the functions it is allowed to call. I tried to complete the back 
	end of the program in full before I started on the GUI so I could make it flexible enough to adapt to any GUI that i decided to 
	use. Eventually I went with a swing GUI but it would be easy to replace that with a text based UI instead. THats why I didn't write
	a text based UI, I knew that if I needed to at the last minute it would be doable.

	Queue and MyQueue: I wanted to make my queues as simple as possible to implement so I 
	could get started on the bigger project so I implemented it as an unbounded circular array.
	I let the caller specify the number of expected elements to cut down on queue expanding run time.
	
	PriorityQueue: I decided to implement the mode function (normal queue and priority queue) both
	in PriorityQueue for modular simplicity. I used a regular queue inside the PriorityQueue to help 
	keep track of the normal order of elements. I also used a generic wrapper class QueueItemShell
	to wrap the objects and hold data about their priority and the order in which they were added. 
	this allowed me to compare the elements when I dequeued. I kept persistent sets of elements in 
	both the normal queue and array of other queues assigned priorities. My method maybe inefficient 
	in both memory space and time (to keep persistent data in two separate places every time an element 
	is dequeued, either by priority mode or by normal mode, the element in a queue must be dequeued and 
	compared then pushed onto a stack one by one until a match is found) but my method is modular and 
	does not violate the rule of demeter (no objects reach way into other objects they didn't create 
	to call methods that have nothing to do with them). With my PriorityQueue switching between priority 
	and normal mode is seamless. It's just a different view of the same data. I realize I probably could 
	have made a regular Priority Queue and used it in this class in combo with a normal queue but having 
	direct access to the PriorityQueue's internal workings makes the dequeue operation a lot faster, instead 
	of dumping all the elements out looking for the right one, we already know which sub-queue the element is 
	in and can start looking directly there.
	
	MovieQueue: I wanted the higher level functions of this project to be as simple as possible. if you take a 
	look at the MovieQueue class you can see how simple it is. it push all logic to the work horse of the queues.
	the methods in MovieQueue directly relate to the function of the end program but are completely decoupled from 
	any view. There are methods for displaying the queues that turn the queues into array form for simplicity in the GUI.
	The caller is expected to call the display methods right after enqueueing or dequeueing elements. I needed to implement 
	a deep copier class in order to correctly display the queues as a series of arrays, so I used a static method called copy 
	and instead of recursivly reaching into the object and copyied every single queue, object, array, value, and field, I decided
	to serialize the whole thing and then deserialize it which creates and exact copy of the object. It was also convient becuase 
	my objects mostly all implement serialize already.
	
	FileManager: I decided to create one place to have methods that deal with files, this is it. This class helps keep 
	the tedious file writing and reading from the main parts of the program and it ensures that that any files opened 
	will be closed. All saved states of objects also go through here to make it easier to keep persistent data. also having
	one place that writes to files keeps the files from being corrupted. I decided to add the persistent data functionality 
	through Serializable. For simplicity's sake I have created very specific methods for saving the exact thing I want to save 
	rather than adhering to more modular code. This allows the upper classes that use this to know nothing of file names and such 
	thing, it just allows the caller to store and retrieve it's specific object. It may not be pretty but it's for the case of security 
	and simplicity.
	
	HeapSorter: I decide to use an entire object for heap sort just to keep all the relevant code in once place even though technically
	since it only has one function it should probably go in a method. I implemented heap sort using both siftUp and siftDown methods. 
	I used siftUp to build the heap out of the given array and the siftDown method to re-bring the largest element to the top after 
	putting the leaf there. I implemented it without in an in-place algorithm style so it takes no extra memory. What else can I say?
	It's heap sort, it's pretty awesome in and of it's self. I could not implement the fast version. :(
	
	MovieLibrary: It might be a little heavy but the MovieLibray contains the list of all movies AND the methods involving the searching 
	of them. The uniqueness of my project is that i abstracted the search feature by making a new class called StringPointerPair which 
	has member variables a String and a pointer to it's relevant movie. for instance the directorList contains an array of StringPointerPairs
	which all contain as a field the name of the director and a link to the movie they directed. I did this at first so I could search for 
	actors and bring up all the movies they had stared in at once instead of just one by putting on StringPointerPair instance for each actor 
	credit in all the movies in one array and then search that list for the actor, that way when several instances of the actors name came up it
	meant that each of the instances pointed to different movies. After a bit of though though I figured to do this will all relevant tags 
	(actor, director genre ect) that way i could abstract the search function and make it generic instead of having to repeat it once just 
	for actors and once for everything else. All of the sort and search methods return an array of Movies so the caller never knows about the 
	internal shellclass that wraps the movie and tag. I plan for my UI to be a series of constantly refreshing displays of Movie arrays, that is why
	I return an array of Movies.
	
	MovieSystemManager: I wanted to have one top class to abstract all user functions so that implementing any GUI would be flexible and easy. MovieSysytemManager
	takes care of making sure that all functions are handled through one class. The MSM contains the movie library and the queue system, and has functions
	for searching that library and enqueuing and dequeueing movies. All data is held in the back end and the MSM relays that data using arrays that represnt 
	the queues and libraries that way the GUI has no way of directly modifying the data in the back end which could potentially lead to data corruption.
	This complete separation from data and UI gives the software the flexibility to implement multiple UI even at the same time while having none interfere
	with each other. 
	
	GUI: I tryed to use a swing plugin for eclipse but gave up soon after I tried the netbeans gui builder. The netbeans gui builder was simple and easy to use and
	hook up my functions with the buttons and displays. I tryed to make my UI as flexible and intuitive as possible. there are 4 displays(search, library, waiting 
    queue, and home queue). The user all ways must add a priority to the movie they add but may ignore it when getting the movie sent to them by clicking deliver 
    instead of deliver by priority. My program assumes a pay to play buisness model so it allows the user to add the same movie infinite amount of times because 
    every time they add a movie they pay for it and eventually if they add it enough the company using the software will make more dvd's for this person. 
	
	Movie: My Movie object consists of a Title, Director, Genre, and three actors. It is serializeable.
	
	

Test Cases
Key: Working As Expected = WAE
	 Unknown Bug = UB
	 Known Bug = KB

	Individual Class Tests (Modular Testing):
	
		MyQueue:
		
			Case 1: tested enqueue operation, 
					filled up queue until it was full and then tried to add another element,
					element was added 10/08/2011. WAE.
			
			Case 2: tested dequeue operation,
					dequeued a full queue until it was empty and then tried to dequeue again
					null was returned and no element was removed. 10/06.2011 WAE.
					
			Case 3: tested circular array functionality
					enqueued several elements, dequeued several elements, enqueued several more
					to ensure wrap around. No problems occurred, all elements accounted for. 10/06/2011 WAE.
					
		
		PriorityQueue:
			
			Case 1: tested enqueue by priority operation,
				    enqueued elements until full with various priorities then enqueued one more
				    new element was added. enqueued elements with all the 
				    same priorities until full and tried to add one more, element was added.
				     10/08/2010. WAE.
				    
			Case 2: tested dequeue by priority operation,
					tried to dequeue an empty queue, null was returned. filled up a queue and removed
					all elements, then tried to remove one more, null was returned. Added elements of 
					different priorities in different orders, when dequeued all elements came out in 
					order of priority and then by FIFO style. 10/06/2011 WAE.
					
			Case 3: tested enqueue normal mode,
					enqueued several elements until full, then enqueued one more,
					item not enqueued. 10/08/2011. WAE.
					
			Case 4: tested dequeue normal mode,
					tried to dequeue an empty queue, null was returned. 10/06/2011. WAE.
					
			Case 5. tested enqueue by priority and dequeue normally,
					enqueued several elements by varying priorities and then dequeued normally
					all elements came out in order stored regardless of priority. 10/06/2011. WAE
					
			Case 6. tested enqueue with no priority and then enqueued by priority and dequeued by priority,
					enqueued several elements by priority and also without a specified priority then 
					dequeued them all by priority. They call came out in correct order. 10/06/2011. WAE.
				
		MovieQueue:
		
		FileManager:
			
			Case 1: tested ability to read movies.txt file and create list of movies
					All movies were read in and displayed correctly. 10/07/2011. WAE
					
			Case 2: tested ability to append movies to the movies.txt file
					movies all added correctly and correctly turned into movie objects when called to.
					10/07/2011. WAE.
					
			Case 3: tested save and retrieve methods,
					created a queue and saved it, ended the program, opened the queue and appended it.
					10/07/2011. WAE.
					
					

Conclusions